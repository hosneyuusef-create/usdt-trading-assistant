نسخه: v1.2 — هر تغییر باید با درج تاریخ، نام مسئول و تأیید مالک محصول در همین فایل ثبت شود. نسخه‌های پیشین در شاخه `marahel_history/` بایگانی می‌شوند. استفاده از Docker در هیچ مرحله‌ای مجاز نیست؛ کل سامانه باید Native روی Windows اجرا شود. قبل از شروع هر مرحله، Playbook (`global_playbook.md`) و Assumptions Log مرکزی (`artefacts/assumptions_log.md`) باید مرور شود.

اصل عمومی کیفیت: برای هر مرحله، معیار پذیرش باید حداقل یک شاخص کمی (تعداد Artefact، زمان اجرا، پوشش تست یا مقدار SLA) و مسیر خروجی مشخص داشته باشد. اگر هر آیتم خروجی یا معیار پذیرش مستند نشود، مرحله «تکمیل‌شده» محسوب نمی‌شود.

ساختار مشترک هر مرحله
- پیش‌نیازها: مراحل یا Artefactهای لازم پیش از شروع.
- وابستگی‌ها: مراحلی که از خروجی این مرحله استفاده می‌کنند.
- ورودی‌ها / خروجی‌ها: فهرست Artefact با مسیر و فرمت.
- خروجی‌های ملموس: اقلامی که باید تولید و ذخیره شوند.
- معیار پذیرش: شرایط کمی/قابل‌سنجش برای اعلام اتمام.
- نکات و ریسک‌ها: ملاحظات خاص.
- برنامه گام‌به‌گام: توالی اجرای مرحله.
- تست‌ها: تست‌های اجباری یا گزارش‌های مورد نیاز.
- Assumptions & Open Questions: پرسش‌ها یا فرض‌هایی که باید قبل از مرحله بعدی بسته شوند.

مرحله 1: جمع‌بندی الزامات و محدودیت‌ها (مستند مرجع الزامات)
پیش‌نیازها: دسترسی کامل به `dastoor.txt` و حضور نمایندگان محصول، فنی و کسب‌وکار.
وابستگی‌ها: مراحل 2، 3، 4، 5، 6، 7، 8، 9، 24، 25.
ورودی‌ها / خروجی‌ها:
- ورودی: `dastoor.txt` (الزامات کسب‌وکار).
- خروجی: `artefacts/RTM_v1.1.csv`, `artefacts/stakeholder_signoff_stage1.pdf`.
- تمپلیت استاندارد: artefacts/templates/stakeholder_signoff_stage1.md (که پس از تکمیل به فرمت PDF به نام artefacts/stakeholder_signoff_stage1.pdf تبدیل می‌شود).
خروجی‌های ملموس:
- RTM کامل با ستون‌های: Requirement-ID، اولویت (MoSCoW)، توضیح خلاصه کسب‌وکار، Stage مسئول (M#)، Artefact خروجی/تست، شماره تست (M#-E2E-# در صورت ایجاد)، وضعیت (Answered/Pending/Rejected)، مسئول پاسخ‌گویی، تاریخ به‌روزرسانی.
- صورتجلسه تصویب با امضای نماینده محصول، فنی، کسب‌وکار.
معیار پذیرش:
- برای تمام الزامات Must/Should ستون «وضعیت پاسخ» مقدار «Answered» دارد و ستون «Owner» تهی نیست.
- هیچ سطر Must/Should با وضعیت «Unresolved» باقی نمی‌ماند.
- صورتجلسه تصویب امضا شده و در مسیر خروجی ثبت شده است.
نکات: اختلاف برداشت در سیاست‌های تسویه یا محرمانگی باید اینجا رفع شود.
برنامه گام‌به‌گام: استخراج الزامات، تکمیل RTM، بازبینی متقاطع، جلسه رسمی تأیید، آرشیو نسخه قفل‌شده.
تست‌ها: بازبینی تصادفی 10 الزام در RTM و تطبیق با سند مرجع.
Assumptions & Open Questions: ثبت پرسش‌های بدون پاسخ و مشخص‌کردن مسئول پاسخ‌گویی تا پیش از شروع مرحله 2.

مرحله 2: تعیین استک تکنولوژیک و سیاست‌های فنی
پیش‌نیازها: تکمیل مرحله 1.
وابستگی‌ها: مراحل 3، 5، 8، 9، 24، 25.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/RTM_v1.1.csv`.
- خروجی: `artefacts/TechStack_Decisions.md`, `artefacts/ADR/ADR-Stack-Selection.md`.
خروجی‌های ملموس:
- جدول استک با زبان (Python 3.11.2)، فریم‌ورک (FastAPI 0.110)، DB (PostgreSQL 15)، سیستم‌عامل هدف (Windows Server 2019)، کتابخانه تلگرام (python-telegram-bot 20.x)، پیام‌صف (RabbitMQ Windows Service)، لاگینگ (Serilog-style JSON).
- مستند منع Docker و ضرورت اجرای Native.
معیار پذیرش:
- تمام اقلام جدول نسخه دقیق و استدلال انتخاب/رد دارند.
- برای هر تصمیم کلیدی ADR ثبت شده با بخش Trade-off و تأثیر بر NFR.
- POC اتصال Postgres و Bot تلگرام روی ماشین Windows گزارش شده است.
نکات: نسخه‌های انتخابی باید روی Windows قابل‌نصب باشند.
برنامه گام‌به‌گام: جمع‌آوری گزینه‌ها، مقایسه، نگارش ADR، اجرای POC، نهایی‌سازی سند.
تست‌ها: اجرای اسکریپت اتصال DB و ارسال پیام تلگرام در محیط Dev.
Assumptions & Open Questions: هر تصمیم معلق (مثلاً انتخاب صف) باید مسئول و مهلت داشته باشد.

مرحله 3: طراحی معماری کلان
پیش‌نیازها: مراحل 1 و 2.
وابستگی‌ها: 4، 6، 7، 8، 9، 19، 23، 24، 25.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/TechStack_Decisions.md`, الزامات سناریو از RTM.
- خروجی: `artefacts/architecture/C4_Context.pdf`, `.../C4_Container.pdf`, `.../C4_Component.pdf`, `artefacts/scenario_mapping_stage3.xlsx`.
خروجی‌های ملموس:
- مجموعه دیاگرام‌های C4 که برای هر سناریوی `dastoor.txt` (خرید، فروش، اختلاف) مسیر موفق و دو مسیر شکست را مستند می‌کند.
- جدول سناریو ↔ دیاگرام ↔ Stage (ایدی سناریو، لینک به دیاگرام، کنترل‌های امنیتی).
معیار پذیرش:
- حداقل 3 سناریوی اصلی با مسیرهای شکست در دیاگرام‌ها مشخص است.
- هر دیاگرام با نسخه و تاریخ امضا شده و در مخزن Artefact ذخیره شده است.
نکات: نشت اطلاعات قبل از Award باید در مرزهای امنیتی مشخص شود.
برنامه گام‌به‌گام: گردآوری سناریوها، ترسیم، بازبینی امنیتی، نهایی‌سازی.
تست‌ها: Walkthrough خرید و اختلاف بر اساس دیاگرام و تأیید با تیم.
Assumptions & Open Questions: اگر سرویس جدید لازم باشد (مثلاً Notification Service) باید پیش از مرحله 4 مشخص شود.

مرحله 4: طراحی مدل دامنه و موجودیت‌ها
پیش‌نیازها: مراحل 1 و 3.
وابستگی‌ها: 5، 9 تا 24.
ورودی‌ها / خروجی‌ها:
- ورودی: C4 Component، RTM.
- خروجی: `artefacts/DomainEntities.xlsx`, `artefacts/domain_glossary.md`.
خروجی‌های ملموس:
- جدول 15 موجودیت اصلی با فیلد کلیدی، توضیح، و نقش در Partial-Fill/Dispute.
- واژه‌نامه دامنه با تعاریف یکسان.
معیار پذیرش:
- تمام موجودیت‌های Stage 5 و بعدی در جدول تعریف شده‌اند.
- برای هر موجودیت ارتباط با سایر موجودیت‌ها (1:N یا N:M) مشخص شده است.
نکات: تاریخچه تغییرات باید پشتیبانی شود.
برنامه گام‌به‌گام: استخراج موجودیت‌ها، طراحی ERD، نگارش واژه‌نامه، بازبینی.
تست‌ها: اعتبارسنجی داده نمونه RFQ→Quote→Award→Settlement→Dispute.
Assumptions & Open Questions: هر فیلد بدون تعریف باید قبل از مرحله 5 تعیین تکلیف شود.

مرحله 5: طراحی دیتابیس و Migrationهای اولیه
پیش‌نیازها: مراحل 2 و 4.
وابستگی‌ها: 9 تا 23، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/DomainEntities.xlsx`, ERD.
- خروجی: `db/schema/database_schema_v1.sql`, `db/migrations/001_initial_schema.sql`, `db/migrations/rollback/001_initial_schema_rollback.sql`, `artefacts/SchemaPerformanceReport.md`.
خروجی‌های ملموس:
- شمای کامل با 15 جدول (بر اساس موجودیت‌های مرحله 4) و روابط.
- Migration v1 و Rollback.
- گزارش کارایی با حداقل 30 ایندکس (5 Composite، 2 GIN).
معیار پذیرش:
- Queryهای اصلی با `EXPLAIN ANALYZE` زمان <50ms روی داده نمونه 10k رکورد دارند.
- Migration و Rollback بدون خطا روی DB خالی اجرا و گزارش شده‌اند.
نکات: قفل‌گذاری و کارایی باید مستند شود.
برنامه گام‌به‌گام: طراحی شِما، نوشتن Migration، اجرای تست کارایی، مستندسازی.
تست‌ها: `test_migration.py`, `test_performance.py`.
Assumptions & Open Questions: هیچ فیلد بدون نوع داده مشخص باقی نماند.

مرحله 6: طراحی قراردادهای API و وب‌هوک تلگرام
پیش‌نیازها: مراحل 3 و 4.
وابستگی‌ها: 9 تا 23، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: C4 Component، Domain Entities، Schema.
- خروجی: `api/settlement_api.yaml`, `api/telegram_webhook.yaml`, `artefacts/api_validation_report.md`.
خروجی‌های ملموس:
- OpenAPI/AsyncAPI با شمای `EvidenceProof` و سایر endpointهای RFQ/Settlement/Dispute.
- مستند ممیزی امنیتی داده پیش از Award.
معیار پذیرش:
- برای تمام endpointها JSON Schema وجود دارد و ولیدیشن با `openapi-cli` پاس می‌شود.
- شمای شواهد Non-cust شامل فیلدهای Hash، issuer، payer/payee، amounts، tx_id، network و claimed_confirmations است.
نکات: Rate limiting و idempotency برای وب‌هوک باید مشخص باشد.
برنامه گام‌به‌گام: تدوین API، بازبینی امنیتی، نشر نسخه قفل شده.
تست‌ها: Contract Test با Mock Server.
Assumptions & Open Questions: هر وابستگی به سرویس بیرونی باید مشخص شود.

مرحله 7: طراحی جریان‌های کاری و وضعیت‌ها
پیش‌نیازها: مراحل 3، 4، 6.
وابستگی‌ها: 10 تا 18، 20، 21، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: API Specs، ERD، معماری.
- خروجی: `artefacts/Workflow_Statecharts.pdf`, `artefacts/Workflow_BPMN.bpmn`.
خروجی‌های ملموس:
- State Machine سفارش کل و بخش‌های Partial-Fill با وضعیت‌های Settled، Partially_Disputed، Fully_Disputed و Transition‌های جایگزینی.
- قوانین SLA و تمدید مهلت با مقدار.
معیار پذیرش:
- هر وضعیت و Transition در فایل BPMN و PDF ثبت شده و با API هم‌خوان است.
- قواعد Escalation برای breach SLA مستند است.
نکات: مسیرهای شکست باید شامل failure رزرو Partial-Fill باشد.
برنامه گام‌به‌گام: ترسیم، بازبینی با ادمین، نهایی‌سازی.
تست‌ها: شبیه‌سازی گردش کامل و سناریوی «عدم دریافت پیشنهاد».
Assumptions & Open Questions: اگر حالت جدید نیاز باشد باید قبل از مرحله 8 تعیین شود.

مرحله 8: آماده‌سازی محیط توسعه و CI پایه (بدون Docker)
پیش‌نیازها: مرحله 2.
وابستگی‌ها: 9 تا 25.
ورودی‌ها / خروجی‌ها:
- ورودی: Tech Stack، Workflow.
- خروجی: `scripts/setup/zero_to_dev.ps1`, `artefacts/ZeroToDev_Guide.ps1.md`, `artefacts/zerotodev_execution.log`, `artefacts/zerotodev_demo.mp4`, `tests/data/seed/seed.ps1`, `tests/data/seed/sample_data.sql`.
خروجی‌های ملموس:
- اسکریپت نصب کامل روی Windows (نصب DB، Queue، Service).
- راهنمای Zero-to-Dev مشخصاً برای Windows 10/11 و Windows Server 2019+.
- ویدئو و Log اثبات اجرای <30 دقیقه.
معیار پذیرش:
- اجرای اسکریپت روی VM تمیز (لاگ تایم‌استمپ) زیر 30 دقیقه.
- Service با اکانت محدود اجرا می‌شود و رول‌بک Seed/Migration کار می‌کند.
نکات: مسیر نصب نباید نیازمند دسترسی Admin دائمی باشد.
برنامه گام‌به‌گام: تولید اسکریپت، تست روی VM، تولید ویدئو، مستندسازی.
تست‌ها: M8-E2E-1..4 + تست خطای دسترسی (M8-E2E-5).
Assumptions & Open Questions: ابزارهای مورد نیاز (PowerShell نسخه 7.x) باید قبل از مرحله بعد تأمین شود؛ در صورت خرابی محیط یا شکست نصب، راهنمای `docs/environment_recovery_guide.md` دنبال شود و نتیجه در این بخش ثبت گردد.

مرحله 9: اسکلت‌بندی Backend و زیرساخت پیکربندی
پیش‌نیازها: مراحل 2، 3، 5، 6، 8.
وابستگی‌ها: 10 تا 23، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: شمای DB، API Specs، Setup Scripts.
- خروجی: `src/backend/`, `artefacts/Secrets_Management.md`, `artefacts/config_structure.yaml`.
خروجی‌های ملموس:
- ساختار پوشه‌ها، DI، ماژول‌های Core/Infra.
- راهکار Secrets: استفاده از Windows Credential Manager با نام `USDT_<SECRET_NAME>`.
معیار پذیرش:
- سرویس با بارگذاری Config‌های محیطی بوت می‌شود و در نبود Secret خطای Fail Fast تولید می‌کند.
- Healthcheck 200 پاسخ می‌دهد و dependency‌ها را چک می‌کند.
نکات: هیچ Secret در repo ذخیره نشود.
برنامه گام‌به‌گام: ایجاد ساختار، پیاده‌سازی DI، تنظیم Secrets، تست Health.
تست‌ها: M9-E2E-1, M9-E2E-2.
Assumptions & Open Questions: اگر Secret جدید لازم باشد، باید قبل از مرحله 10 تعریف شود.

مرحله 10: هویت و وریفای مشتری
پیش‌نیازها: مراحل 4، 5، 6، 9.
وابستگی‌ها: 13، 16، 20، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: DB Schema، API، Config Structure.
- خروجی: `src/backend/customer`, `artefacts/Verification_Policies.json`.
خروجی‌های ملموس:
- ثبت‌نام و احراز مشتری، ثبت کارت/کیف‌پول با ماسکینگ.
- سیاست سقف‌ها در فایل JSON (Basic=1,000,000؛ Advanced=10,000,000؛ Premium=100,000,000 تومان).
معیار پذیرش:
- تست ثبت‌نام تا افزودن کارت پاس می‌شود و سقف‌ها enforce شده‌اند.
- لاگ ماسکینگ کارت و ذخیره امن تأیید می‌شود.
نکات: کارت باید با الگوریتم بررسی رقم کنترلی اعتبارسنجی شود.
برنامه گام‌به‌گام: پیاده‌سازی Auth، ثبت کارت/کیف‌پول، اعمال سقف‌ها، مستندسازی.
تست‌ها: M10-E2E-1, M10-E2E-2.
Assumptions & Open Questions: هر کارت یا کیف‌پول با فرمت خاص باید تأیید شود.

مرحله 11: مدیریت پرووایدر و الزامات پایه
پیش‌نیازها: مراحل 4، 5، 6، 9.
وابستگی‌ها: 14، 15، 16، 17، 20، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Schema، API، Verification Policies.
- خروجی: `src/backend/provider`, `artefacts/Provider_Eligibility.md`.
خروجی‌های ملموس:
- ثبت و مدیریت پرووایدر، سیاست وثیقه/امتیاز.
- سند Eligibility با حداقل امتیاز 70 و وثیقه 200,000,000 تومان.
معیار پذیرش:
- فیلتر واجدشرایطی اعلان RFQ با مقادیر بالای وثیقه/امتیاز اجرا می‌شود.
- لاگ تصمیمات صلاحیت ذخیره می‌شود.
نکات: به‌روزرسانی امتیاز باید در مرحله 20 پیاده‌سازی شود.
برنامه گام‌به‌گام: API Provider، سیاست‌ها، فیلتر واجدشرایطی، ثبت لاگ.
تست‌ها: M11-E2E-1, M11-E2E-2.
Assumptions & Open Questions: هر تغییری در مقادیر حداقل باید در این سند ثبت شود.

مرحله 12: نقش‌ها و دسترسی‌ها
پیش‌نیازها: مراحل 6، 9.
وابستگی‌ها: 13 تا 23، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: API، ساختار Backend.
- خروجی: `src/backend/security/rbac`, `artefacts/rbac_matrix.xlsx`, `logs/access_audit.json`.
خروجی‌های ملموس:
- RBAC با حداقل دسترسی لازم، ثبت رویدادهای دسترسی.
- ماتریس نقش → مجوز.
معیار پذیرش:
- تست دسترسی ناکافی و دسترسی کامل ادمین پاس می‌شود.
- رویدادهای دسترسی در جدول Audit Logs ثبت می‌شود.
نکات: Privilege Escalation باید جلوگیری شود.
برنامه گام‌به‌گام: تعریف نقش‌ها، پیاده‌سازی گاردها، ثبت رویدادها.
تست‌ها: M12-E2E-1, M12-E2E-2.
Assumptions & Open Questions: اگر نقش جدید ایجاد شود، باید در ماتریس ثبت شود.

مرحله 13: RFQ ایجاد و مدیریت
پیش‌نیازها: مراحل 4، 5، 6، 7، 9، 10، 12.
وابستگی‌ها: 14، 15، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Schema، Workflow، RBAC.
- خروجی: `src/backend/rfq`, `artefacts/rfq_special_conditions.schema.json`.
خروجی‌های ملموس:
- API/تلگرام ایجاد/ویرایش/لغو RFQ با تایمر فعال.
- JSON Schema شرایط خاص (price_ceiling، split_allowed، specific_providers[]).
معیار پذیرش:
- Validation شرایط خاص مطابق Schema.
- تایمرها و محدودیت‌های وریفای enforce شده‌اند.
نکات: لغو قبل از Award باید لاگ شود.
برنامه گام‌به‌گام: پیاده‌سازی API، Timer، Validation، تست.
تست‌ها: M13-E2E-1, M13-E2E-2.
Assumptions & Open Questions: شرایط خاص جدید باید در Schema افزوده شود.

مرحله 14: اعلان RFQ و دریافت Quote
پیش‌نیازها: مراحل 6، 7، 9، 11، 13.
وابستگی‌ها: 15، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: RFQ API، Eligibility، Workflow.
- خروجی: `src/backend/notifications`, `artefacts/quote_validation.md`.
خروجی‌های ملموس:
- اعلان ناشناس، ثبت Quote با محدودیت ظرفیت و Rate Limit.
- مستند جلوگیری از اسپم.
معیار پذیرش:
- حداقل دو پیشنهاد در بازه تستی پذیرفته می‌شود.
- پیشنهاد دیرهنگام رد و لاگ می‌شود.
نکات: محدودیت نرخ باید با تلگرام سازگار باشد.
برنامه گام‌به‌گام: اعلان، ذخیره Quote، validation، تست.
تست‌ها: M14-E2E-1, M14-E2E-2.
Assumptions & Open Questions: سطح Rate Limit تلگرام باید مانیتور شود.

مرحله 15: رتبه‌بندی و انتخاب برنده (Award)
پیش‌نیازها: مراحل 7، 13، 14.
وابستگی‌ها: 16، 17، 19، 24.
وریدی‌ها / خروجی‌ها:
- ورودی: Quote ها، Workflow، Eligibility.
- خروجی: `src/backend/award_engine`, `artefacts/Award_Audit.xlsx`, `artefacts/scoring_rules.md`.
خروجی‌های ملموس:
- موتور رتبه‌بندی با قیمت مؤثر و Tie-break.
- فرم ممیزی Award دستی با ستون‌های Reviewer، Approver، decision_reason، tie_break_rule، timestamp.
معیار پذیرش:
- تست انتخاب خودکار با تساوی و Partial-Fill موفق است.
- ثبت ممیزی (M15-CL-4) برای هر Award دستی انجام می‌شود.
نکات: شفافیت کامل برای Audit.
برنامه گام‌به‌گام: پیاده‌سازی موتور، قوانین Tie-break، ثبت رویداد، ممیزی.
تست‌ها: M15-E2E-1, M15-E2E-2.
Assumptions & Open Questions: وزن معیارها باید با مرحله 20 سازگار باشد.

مرحله 16: تسویه مرحله‌ای ریال/USDT
پیش‌نیازها: مراحل 7، 10، 11، 15.
وابستگی‌ها: 17، 18، 20، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Award، Evidence Schema، Settlement API.
- خروجی: `src/backend/settlement`, `artefacts/Evidence_Spec.md`.
خروجی‌های ملموس:
- گردش دوگام ریال/USDT با آپلود رسید/TxID، تایمر، مدیریت مابه‌التفاوت.
- مستند Evidence با فیلدها، نوع داده، حداکثر اندازه (5MB)، مسیر ذخیره، نگهداری 180 روز.
معیار پذیرش:
- Escalation خودکار به Dispute در عدم بارگذاری یا رد رسید.
- مسیر رسید نامعتبر → فرصت بارگذاری مجدد → Dispute ثبت شده است.
نکات: Non-custodial principle باید رعایت شود.
برنامه گام‌به‌گام: پیاده‌سازی Steps، تایمر، Validation، Escalation، مستندسازی.
تست‌ها: M16-E2E-1..4.
Assumptions & Open Questions: شاخص‌های delay باید در مرحله 19/23 ثبت شود.

مرحله 17: Partial-Fill، بازتخصیص و لغو Award
پیش‌نیازها: مراحل 14، 15، 16.
وابستگی‌ها: 16، 18، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Award Engine، Settlement، Workflow Statecharts.
- خروجی: `src/backend/partial_fill`, `artefacts/Order_Reconciliation.xlsx`.
خروجی‌های ملموس:
- تقسیم سفارش، لغو/جایگزینی بخش معیوب، عدم اختلال بخش‌های سالم.
- جدول Mapping وضعیت بخش‌ها → وضعیت کل.
معیار پذیرش:
- سناریوهای شکست یک بخش، گزارش وضعیت مستقل و ترکیبی عمل می‌کند.
- وضعیت کل طبق جدول آشتی به‌روز می‌شود.
نکات: باید از آلودگی بخش‌های سالم جلوگیری شود.
برنامه گام‌به‌گام: پیاده‌سازی تقسیم، جایگزینی، آشتی وضعیت.
تست‌ها: M17-E2E-1..3.
Assumptions & Open Questions: اگر وضعیت جدید نیاز است، باید قبل از مرحله 18 تعریف شود.

مرحله 18: مدیریت اختلاف و داوری
پیش‌نیازها: مراحل 7، 16، 17.
وابستگی‌ها: 19، 20، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Evidence، Partial-Fill، Workflow Dispute.
- خروجی: `src/backend/dispute`, `artefacts/Dispute_Workflow.md`.
خروجی‌های ملموس:
- فرآیند ثبت اختلاف، طلب مدارک، گردش داوری، اعلان تصمیم.
- سند Workflow با مهلت: ثبت اختلاف → درخواست مدارک (30 دقیقه) → بررسی (60 دقیقه) → رأی نهایی ≤ 4 ساعت.
معیار پذیرش:
- ثبت پیام‌های طرفین و اعلان رأی مطابق SLA انجام می‌شود.
- اختلاف تا رأی نهایی مسیر کامل دارد.
نکات: مدیریت زمان برای Non-custodial اهمیت دارد.
برنامه گام‌به‌گام: پیاده‌سازی ثبت اختلاف، پردازش مدارک، داوری، اعلان نتیجه.
تست‌ها: M18-E2E-1..4.
Assumptions & Open Questions: اگر SLA تغییر کند، باید در این سند اصلاح شود.

مرحله 19: پیام‌ها و نوتیفیکیشن‌ها
پیش‌نیازها: مراحل 6، 15، 16، 18.
وابستگی‌ها: 10 تا 18، 21، 22، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: قالب‌های پیام از `dastoor.txt`، Evidence Spec، Telemetry Requirements.
- خروجی: `artefacts/message_templates/`, `artefacts/Notification_Disclaimer.txt`, `artefacts/Telemetry_Config.json`.
خروجی‌های ملموس:
- موتور قالب پیام، کانال تلگرام/هشدار سیستمی، به‌روزرسانی امن قالب‌ها.
- متن دیسکلِیمر Non-custodial (فارسی/انگلیسی) در تمام پیام‌های اختلاف و تسویه.
- تنظیمات تلمتری شامل metricهای `notification_latency_p95_ms`, `notification_failure_rate`, `dispute_escalation_rate` با منبع و آستانه هشدار.
معیار پذیرش:
- Dry-run پیام‌های نمونه بند 12 `dastoor.txt` بدون خطا.
- Metrics در محیط تست جمع‌آوری و آستانه‌ها اعمال می‌شود.
نکات: تغییر قالب باید با کنترل نسخه انجام شود.
برنامه گام‌به‌گام: تدوین قالب‌ها، پیاده‌سازی موتور، افزودن دیسکلِیمر، تنظیم تلمتری، تست.
تست‌ها: M19-E2E-1..4.
Assumptions & Open Questions: اگر کانال جدید اضافه شود باید در این مرحله مستند گردد.

مرحله 20: امتیازدهی و محدودیت‌ها
پیش‌نیازها: مراحل 10، 11، 16، 18.
وابستگی‌ها: 11، 13، 14، 21، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Eligibility، Dispute outcomes، Settlement logs.
- خروجی: `src/backend/scoring`, `artefacts/Scoring_Model.xlsx`.
خروجی‌های ملموس:
- مدل امتیاز با وزن Success Rate 40%، On-time Settlement 30%، Dispute Ratio 20%، Manual Alerts 10%.
- قواعد تأثیر امتیاز بر سقف دسترسی (مثلاً امتیاز ≤60 دسترسی محدود به معاملات ≤50M تومان).
معیار پذیرش:
- اعمال تغییر امتیاز پرووایدر بر Eligibility و سقف‌ها تأیید می‌شود.
- لاگ تغییرات امتیاز در Audit ذخیره می‌شود.
نکات: باید با گزارش‌های مرحله 21 سازگار باشد.
برنامه گام‌به‌گام: پیاده‌سازی موتور امتیازدهی، اتصال به Eligibility، مستندسازی.
تست‌ها: M20-E2E-1, M20-E2E-2.
Assumptions & Open Questions: هر تغییر وزن باید در Scoring Model ثبت شود.

مرحله 21: گزارش‌ها و داشبورد ادمین
پیش‌نیازها: مراحل 13 تا 20.
وابستگی‌ها: 25.
ورودی‌ها / خروجی‌ها:
- ورودی: داده‌های عملیاتی (RFQ, Settlement, Dispute)، Scoring Model.
- خروجی: `reports/kpi_dashboard/`, `artefacts/report_specs_stage21.xlsx`.
خروجی‌های ملموس:
- سه گزارش اصلی: RFQ Summary، Settlement KPI، Dispute Outcomes. ستون‌ها، بازه زمانی، منبع داده و روش cross-check مشخص است.
- امکان فیلتر و Export CSV/Excel.
معیار پذیرش:
- صحت اعداد با داده آزمایشی و مقایسه با Audit Logs تأیید می‌شود.
- هر گزارش مستند spec دارد و در CI تست می‌شود.
نکات: شاخص‌ها باید با اهداف NFR سازگار باشند.
برنامه گام‌به‌گام: طراحی Query، پیاده‌سازی گزارش، اعتبارسنجی با Audit، انتشار.
تست‌ها: M21-E2E-1, M21-E2E-2.
Assumptions & Open Questions: گزارش جدید باید در spec ثبت شود.

مرحله 22: تنظیمات قابل تغییر (Configuration UI/API)
پیش‌نیازها: مراحل 6، 9، 19.
وابستگی‌ها: 10 تا 21، 24.
ورودی‌ها / خروجی‌ها:
- ورودی: Config Structure، Notification Templates، Scoring Model.
- خروجی: `src/backend/config_ui`, `artefacts/Config_Versioning.md`, `scripts/config_rollback.ps1`.
خروجی‌های ملموس:
- پنل تنظیمات با RBAC مناسب، نسخه‌گذاری و قابلیت بازگشت.
- استراتژی versioned config store با فیلدهای `version`, `created_at`, `created_by`, `rollback_token`.
معیار پذیرش:
- تغییر تنظیمات بدون نیاز به انتشار مجدد اعمال می‌شود و امکان بازگشت نسخه قبلی از طریق `config_rollback.ps1` وجود دارد.
- History تنظیمات ثبت می‌شود.
نکات: تغییرات باید Audit داشته باشد.
برنامه گام‌به‌گام: پیاده‌سازی UI/API، ذخیره‌سازی نسخه‌دار، تست rollback.
تست‌ها: M22-E2E-1, M22-E2E-2.
Assumptions & Open Questions: اگر تنظیم جدید اضافه شود باید در این سند ثبت گردد.

مرحله 23: لاگینگ و Audit Trail
پیش‌نیازها: مراحل 3، 4، 9، 15، 16، 18.
وابستگی‌ها: 10 تا 22، 24، 25.
ورودی‌ها / خروجی‌ها:
- ورودی: رویدادهای کسب‌وکار، تلمتری، Scoring.
- خروجی: `artefacts/event_schema_spec.json`, `artefacts/logging_strategy.md`.
خروجی‌های ملموس:
- لاگ ساختاریافته با Trace IDs.
- Schema رویدادها با فیلدهای `event_id`, `event_type`, `actor_id`, `actor_role`, `previous_status`, `new_status`, `decision_reason`, `evidence_links[]`, `hash`, `created_at`.
- داشبورد p95 اعلان و نرخ شکست پیام‌ها.
معیار پذیرش:
- بازپخش سناریو خرید و اختلاف از روی لاگ‌ها ممکن است.
- رویدادها immutability دارند؛ هر تغییر با رویداد جدید.
- داشبورد و هشدارها روی داده نمونه و نقض آستانه تست شده‌اند.
نکات: PII Minimization باید رعایت شود.
برنامه گام‌به‌گام: پیاده‌سازی لاگینگ، تعریف Schema، راه‌اندازی داشبورد، تست.
تست‌ها: M23-E2E-1..4.
Assumptions & Open Questions: اگر Metric جدید اضافه شود باید به تلمتری مرحله 19 افزوده شود.

مرحله 24: تست‌های واحد، یکپارچه و E2E + مستندسازی و Training
پیش‌نیازها: مراحل 9 تا 23.
وابستگی‌ها: 25.
ورودی‌ها / خروجی‌ها:
- ورودی: تمام Artefactهای عملیاتی.
- خروجی: `tests/unit/`, `tests/integration/`, `tests/e2e/`, `artefacts/Training_Kit.zip`, `artefacts/test_reports/coverage.xml`, `artefacts/test_reports/unit_test_report.xml`, `artefacts/test_reports/integration_test_report.xml`, `artefacts/test_reports/e2e_test_report.xml`, `artefacts/smoke_mvp_report.md`.
خروجی‌های ملموس:
- Suite تست با پوشش مسیرهای حیاتی ≥80%.
- بسته Training شامل Manual PDF، ویدئو ضبط‌شده، Quiz.
- گزارش Smoke MVP برای سناریوی Manual-Award + TRC20 در محیط محدود.
معیار پذیرش:
- اجرای موفق CI بر اساس `ci/github-actions.yml` و اسکریپت‌های `scripts/tests/run_unit_tests.ps1`, `scripts/tests/run_integration_tests.ps1`, `scripts/tests/run_e2e_tests.ps1` با خروجی پوشش ≥80% خطوط بحرانی و 100% مسیرهای حیاتی.
- Smoke MVP پس از استقرار تستی پاس می‌شود.
- Training Kit تحویل و تاریخچه آموزش ثبت شده است.
نکات: مسیرهای شکست و زمان‌بندی‌ها باید تست شوند؛ راهنمای اجرای تست‌ها در `tests/README.md` مرجع است.
برنامه گام‌به‌گام: نگارش تست‌ها، اجرای اسکریپت‌های استاندارد (محلی یا CI)، تولید Training Kit، اجرای Smoke MVP.
تست‌ها: M24-E2E-1..4.
Assumptions & Open Questions: اگر سناریوی جدید به Smoke اضافه شود باید در گزارش درج گردد.

مرحله 25: استقرار native و تحویل
پیش‌نیازها: مراحل 8، 21، 22، 24، 9 تا 20.
وابستگی‌ها: — 
ورودی‌ها / خروجی‌ها:
- ورودی: Runbookها، گزارش تست، Training Kit.
- خروجی: `artefacts/Prod_Deployment.md`, `artefacts/backup_restore_report.pdf`, `artefacts/award_settlement_dispute_readiness_checklist.xlsx`, `artefacts/final_delivery_checklist.md`.
خروجی‌های ملموس:
- Runbook استقرار Production بدون Docker با مراحل دقیق.
- برنامه Backup/Restore: Differential هر 15 دقیقه، Full روزانه، نگهداری 30 روز؛ تست Restore روی هاست ثانویه مستند شده است.
- چک‌لیست آمادگی Award/Settlement/Dispute با داده نمونه.
معیار پذیرش:
- DRY-RUN استقرار روی سرور مقصد و بازگشت ثبت شده است.
- Backup/Restore گزارش تایید RPO≤15 دقیقه و RTO≤60 دقیقه دارد.
- Smoke پس از استقرار Production پاس شده است.
- فرم `artefacts/final_delivery_checklist.md` تکمیل و امضا شده است؛ RTM، گزارش تست‌ها، Runbook و Artefactهای تحویل در آن ثبت شده‌اند.
نکات: مانیتورینگ پایه و هشدارهای کلیدی باید فعال باشند.
برنامه گام‌به‌گام: آماده‌سازی کانفیگ، استقرار آزمایشی، اجرای رول‌بک، تحویل نهایی.
تست‌ها: M25-E2E-1, M25-E2E-2.
Assumptions & Open Questions: هر تغییری در محیط Production باید در Runbook ثبت شود.
- هنگام ثبت یا به‌روزرسانی فرض جدید، علاوه بر بخش Assumptions همان مرحله، ردیف متناظر در `artefacts/assumptions_log.md` نیز ایجاد/به‌روز شود.
- برای خروجی‌های رسمی از تمپلیت‌های `artefacts/templates/` (ADR، گزارش تست، خلاصه مرحله) استفاده شود.
- پایان هر مرحله مستلزم تکمیل فرم `artefacts/stage_completion_checklist.md` و ضمیمه کردن لینک Artefactها است.
- ساختار پوشه‌ها و مسیرهای ذخیره Artefact مطابق `readme_repo_structure.md` رعایت شود.
- نسخه جاری RTM (`artefacts/RTM_v1.1.csv`) مرجع رسمی ردیابی الزامات است و باید در هر مرحله در صورت نیاز به‌روزرسانی گردد.
- در صورت نیاز به بازگشت تغییرات یا ایجاد Snapshot سالم، راهنمای `docs/change_control_and_revert.md` دنبال و نتایج در مستندات مرحله ثبت شود.



مرحله 26: Telegram Bot - طراحی User Flows و Conversation States
پیش‌نیازها: مراحل 1، 3، 4، 6، 7، 19.
وابستگی‌ها: مراحل 27، 28، 29، 30، 31، 32، 33، 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/Workflow_Statecharts.pdf` (M7), `artefacts/RTM_v1.1.csv` (M1), `artefacts/message_templates/` (M19), `api/telegram_webhook.yaml` (M6).
- خروجی: `artefacts/telegram_bot/TG_User_Flows.pdf`, `artefacts/telegram_bot/TG_Conversation_States.xlsx`, `artefacts/telegram_bot/TG_Keyboards_Design.md`, `artefacts/telegram_bot/TG_Message_Mapping.csv`, `artefacts/telegram_bot/TG_Architecture.md`.
خروجی‌های ملموس:
- نمودار جریان کاربری (User Flow) برای 15 سناریو: Customer (ثبت‌نام، ایجاد RFQ، مشاهده پیشنهادها، تسویه، اختلاف)، Provider (ثبت‌نام، دریافت RFQ، ارسال Quote، تسویه، پاسخ به اختلاف)، Admin (انتخاب برنده، رسیدگی به اختلاف، مشاهده گزارش، تنظیمات، مدیریت پرووایدر).
- جدول State Machine برای هر Conversation Handler با States، Transitions، Entry Actions و Exit Actions.
- طراحی تمام Inline Keyboards با screenshot یا mockup (حداقل 25 keyboard مختلف).
- نقشه mapping پیام‌ها به message templates موجود در M19.
- سند معماری Bot شامل 3-Layer Architecture (Bot Interface، Business Logic، Backend Integration).
معیار پذیرش:
- تمام 15 user flow با جزئیات کامل مستند شده‌اند.
- هر conversation handler با state diagram کامل و تمام transitions مشخص است.
- تمام keyboards با UI mockup و callback_data mapping ثبت شده‌اند.
- mapping پیام‌ها به templates 100% coverage دارد (هیچ پیامی بدون template نیست).
- معماری bot با Backend API موجود سازگار است و هیچ تغییری در Backend لازم نیست.
- بازبینی توسط Product Owner و UX lead انجام شده و تأیید شده است.
نکات: 
- Conversation state باید persistent باشد (در PostgreSQL ذخیره شود).
- Rate limiting تلگرام (30 msg/sec) در طراحی broadcast لحاظ شود.
- File upload size limit (20MB) در طراحی مستندسازی شود.
برنامه گام‌به‌گام: استخراج user journeys از workflows موجود، طراحی conversation states، طراحی keyboards، mapping به templates، طراحی معماری، بازبینی با تیم، نهایی‌سازی اسناد.
تست‌ها: Walkthrough با 3 کاربر واقعی (1 customer، 1 provider، 1 admin) و جمع‌آوری feedback.
Assumptions & Open Questions: آیا از Telegram Mini Apps استفاده می‌شود یا external browser؟ آیا bot از webhook استفاده می‌کند یا long polling؟ این تصمیمات باید قبل از M27 گرفته شوند.


مرحله 27: Telegram Bot - پیاده‌سازی Bot Core و Infrastructure
پیش‌نیازها: مراحل 2، 6، 8، 9، 26.
وابستگی‌ها: مراحل 28، 29، 30، 31، 32، 33، 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_Architecture.md` (M26), `artefacts/TechStack_Decisions.md` (M2), `src/backend/` (M9), `requirements.txt`, `artefacts/Secrets_Management.md` (M9).
- خروجی: `src/telegram_bot/`, `tests/telegram_bot/`, `artefacts/telegram_bot/Bot_Setup_Guide.md`, `artefacts/telegram_bot/Bot_Config_Spec.yaml`.
خروجی‌های ملموس:
- ساختار کامل پروژه Bot:
  src/telegram_bot/
  ├── __init__.py
  ├── main.py (entry point)
  ├── core/ (bot application، config، middleware)
  ├── handlers/ (conversation handlers - خالی در این مرحله)
  ├── services/ (message formatter، keyboard builder، file handler)
  ├── clients/ (backend API client)
  └── models/ (conversation state models)
- Backend API Client کامل با تمام endpoints (Customer، Provider، RFQ، Quote، Award، Settlement، Dispute، Scoring، Analytics، Config).
- Message Formatter با integration به message templates.
- Keyboard Builder برای تولید dynamic inline keyboards.
- Configuration management با Windows Credential Manager.
- Logging و Telemetry با Trace ID.
- Health check endpoint برای bot.
معیار پذیرش:
- Bot بوت می‌شود بدون error و به Backend API متصل می‌شود.
- `/start` و `/help` commands کار می‌کنند و پاسخ صحیح می‌دهند.
- Backend API Client برای حداقل 5 endpoint تست شده و کار می‌کند.
- Message Formatter با حداقل 3 template تست شده و پیام صحیح تولید می‌کند.
- Secrets از Windows Credential Manager بارگذاری می‌شوند (BOT_TOKEN، BACKEND_URL).
- Logs ساختاریافته با Trace ID ثبت می‌شوند.
- Health check `/health` در bot پاسخ می‌دهد و وضعیت Backend را چک می‌کند.
- تست‌های واحد برای API Client و Message Formatter pass می‌شوند.
نکات:
- Bot Token باید در Windows Credential Manager با نام `USDT_BOT_TOKEN` ذخیره شود.
- Retry mechanism با exponential backoff برای API calls.
- Circuit breaker pattern برای جلوگیری از cascade failure.
- همه API calls باید async باشند.
برنامه گام‌به‌گام: ایجاد ساختار پروژه، پیاده‌سازی Bot core، پیاده‌سازی Backend API client، پیاده‌سازی Message formatter، پیاده‌سازی Keyboard builder، تنظیم Secrets management، پیاده‌سازی Logging، نوشتن تست‌های واحد، تست integration با Backend.
تست‌ها: M27-E2E-1 (Bot startup و connection به Backend)، M27-E2E-2 (API client برای Customer registration)، M27-E2E-3 (Message formatter با 3 template)، M27-E2E-4 (Secrets loading از Credential Manager).
Assumptions & Open Questions: آیا bot به RabbitMQ برای notification listening نیاز دارد؟ اگر بله، باید در این مرحله پیاده‌سازی شود یا M30؟


مرحله 28: Telegram Bot - پیاده‌سازی Customer Handlers
پیش‌نیازها: مراحل 10، 13، 16، 26، 27.
وابستگی‌ها: مراحل 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_User_Flows.pdf` (M26)، `artefacts/telegram_bot/TG_Conversation_States.xlsx` (M26)، `src/telegram_bot/core/` (M27)، `src/backend/customer` (M10)، `src/backend/rfq` (M13)، `src/backend/settlement` (M16).
- خروجی: `src/telegram_bot/handlers/customer_registration.py`، `src/telegram_bot/handlers/customer_rfq.py`، `src/telegram_bot/handlers/customer_award_view.py`، `src/telegram_bot/handlers/customer_settlement.py`، `src/telegram_bot/handlers/customer_dispute.py`، `tests/telegram_bot/test_customer_handlers.py`، `artefacts/test_reports/M28_customer_handlers_tests.md`.
خروجی‌های ملموس:
- Conversation Handler برای ثبت‌نام مشتری (نام کامل، KYC tier، کارت بانکی، آدرس wallet).
- Conversation Handler برای ایجاد RFQ (نوع معامله، مقدار، شبکه، سقف قیمت، تأیید).
- Handler برای مشاهده پیشنهادها (لیست quotes با قیمت و ظرفیت).
- Conversation Handler برای Settlement (آپلود رسید بانکی، تأیید TxID دریافتی).
- Conversation Handler برای ثبت اختلاف (انتخاب دلیل، آپلود مدارک، ارسال توضیحات).
- تست‌های واحد و یکپارچگی برای تمام handlers.
معیار پذیرش:
- تمام 5 customer flow کامل پیاده‌سازی شده و با Backend API integrate شده‌اند.
- File upload برای رسید بانکی و مدارک اختلاف کار می‌کند.
- Validation برای تمام ورودی‌ها (مقدار USDT، شماره کارت، آدرس wallet) انجام می‌شود.
- Error handling برای تمام failure scenarios (مثلاً: سقف معامله بیش از حد مجاز).
- تست‌های E2E: M28-E2E-1 (Customer registration → RFQ → Award notification → Settlement → Complete)، M28-E2E-2 (Customer RFQ → No quotes → Extend deadline)، M28-E2E-3 (Customer Settlement → Upload receipt → Dispute)، M28-E2E-4 (Customer tries RFQ above tier limit → Rejected).
- پوشش تست ≥85% برای customer handlers.
نکات:
- Card number باید masked شود در logs (فقط 4 رقم آخر).
- Wallet address باید با network انتخابی validate شود.
- RFQ amount باید با tier limit کاربر چک شود.
- File upload باید با hash verification انجام شود.
برنامه گام‌به‌گام: پیاده‌سازی registration handler، پیاده‌سازی RFQ handler، پیاده‌سازی award view handler، پیاده‌سازی settlement handler، پیاده‌سازی dispute handler، نوشتن تست‌ها، integration testing با Backend، بازبینی کد.
تست‌ها: M28-E2E-1..4.
Assumptions & Open Questions: آیا customer می‌تواند چند RFQ همزمان داشته باشد؟ آیا customer می‌تواند RFQ را قبل از deadline لغو کند؟

مرحله 29: Telegram Bot - پیاده‌سازی Provider Handlers
پیش‌نیازها: مراحل 11، 14، 15، 16، 26، 27.
وابستگی‌ها: مراحل 30، 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_User_Flows.pdf` (M26)، `src/telegram_bot/core/` (M27)، `src/backend/provider` (M11)، `src/backend/quote` (M14)، `src/backend/award_engine` (M15).
- خروجی: `src/telegram_bot/handlers/provider_registration.py`، `src/telegram_bot/handlers/provider_quote.py`، `src/telegram_bot/handlers/provider_award_notification.py`، `src/telegram_bot/handlers/provider_settlement.py`، `src/telegram_bot/handlers/provider_dispute.py`، `tests/telegram_bot/test_provider_handlers.py`، `artefacts/test_reports/M29_provider_handlers_tests.md`.
خروجی‌های ملموس:
- Conversation Handler برای ثبت‌نام پرووایدر (نام، اطلاعات تماس، اطلاعات مالی، وثیقه).
- Conversation Handler برای ارسال Quote (قیمت واحد، ظرفیت، کارمزد شبکه).
- Handler برای notification برنده شدن (اطلاعات تسویه، مهلت‌ها).
- Conversation Handler برای Settlement (آپلود TxID، بارگذاری رسید انتقال).
- Handler برای پاسخ به اختلاف (مشاهده مدارک customer، ارسال پاسخ و مدارک).
معیار پذیرش:
- تمام 5 provider flow کامل پیاده‌سازی شده‌اند.
- Provider notification برای RFQ جدید real-time است (< 5 ثانیه delay).
- Quote submission با validation قیمت و ظرفیت انجام می‌شود.
- Quote نمی‌تواند بعد از deadline ارسال شود.
- TxID validation با format صحیح blockchain.
- تست‌های E2E: M29-E2E-1 (Provider registration → Receive RFQ → Submit quote → Win → Settlement)، M29-E2E-2 (Provider submits quote after deadline → Rejected)، M29-E2E-3 (Provider با امتیاز پایین → Cannot access large RFQs)، M29-E2E-4 (Provider dispute response with evidence).
- پوشش تست ≥85% برای provider handlers.
نکات:
- RFQ notification باید به پرووایدرهای eligible broadcast شود (با rate limiting).
- Provider با score < 60 نباید RFQهای بزرگ را ببیند.
- Quote edit فقط قبل از deadline مجاز است.
برنامه گام‌به‌گام: پیاده‌سازی registration، پیاده‌سازی quote handler، پیاده‌سازی notification receiver، پیاده‌سازی settlement handler، پیاده‌سازی dispute response، نوشتن تست‌ها، integration testing.
تست‌ها: M29-E2E-1..4.
Assumptions & Open Questions: آیا provider می‌تواند quote خود را edit کند؟ آیا provider می‌تواند quote را withdraw کند؟

مرحله 30: Telegram Bot - پیاده‌سازی Admin Handlers و Notification Engine
پیش‌نیازها: مراحل 15، 18، 19، 21، 22، 26، 27، 28، 29.
وابستگی‌ها: مراحل 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_User_Flows.pdf` (M26)، `src/telegram_bot/core/` (M27)، `src/backend/award_engine` (M15)، `src/backend/dispute` (M18)، `src/backend/analytics` (M21)، `src/backend/config_ui` (M22)، `artefacts/message_templates/` (M19).
- خروجی: `src/telegram_bot/handlers/admin_award.py`، `src/telegram_bot/handlers/admin_dispute.py`، `src/telegram_bot/handlers/admin_analytics.py`، `src/telegram_bot/handlers/admin_config.py`، `src/telegram_bot/handlers/admin_provider_mgmt.py`، `src/telegram_bot/services/notification_listener.py`، `src/telegram_bot/services/notification_sender.py`، `tests/telegram_bot/test_admin_handlers.py`، `artefacts/test_reports/M30_admin_notification_tests.md`.
خروجی‌های ملموس:
- Handler برای انتخاب برنده (مشاهده لیست RFQها، مشاهده quotes، انتخاب دستی، انتخاب خودکار).
- Handler برای رسیدگی به اختلاف (مشاهده مدارک طرفین، صدور رأی، ثبت دلیل).
- Handler برای مشاهده گزارش‌ها (analytics، KPI dashboard، export CSV).
- Handler برای تغییر تنظیمات (SLA، قیمت‌دهی، شبکه‌های مجاز، message templates).
- Handler برای مدیریت پرووایدر (تغییر score، suspend، activate).
- Notification Listener (RabbitMQ consumer) برای دریافت events از Backend.
- Notification Sender برای ارسال پیام به تلگرام با retry و delivery tracking.
معیار پذیرش:
- Admin می‌تواند لیست RFQهای منتظر award را ببیند و برنده را انتخاب کند.
- Admin می‌تواند اختلافات را مشاهده و رأی صادر کند.
- Admin می‌تواند گزارش‌ها را مشاهده و export کند.
- Admin می‌تواند تنظیمات را تغییر دهد (با versioning و rollback).
- Notification Engine تمام 10+ event type را پوشش می‌دهد.
- Notifications در زمان واقعی ارسال می‌شوند (< 5 ثانیه delay).
- Retry mechanism برای failed notifications کار می‌کند.
- Delivery tracking با success/failure logs ثبت می‌شود.
- تست‌های E2E: M30-E2E-1 (Admin award selection)، M30-E2E-2 (Admin dispute resolution)، M30-E2E-3 (Admin analytics export)، M30-E2E-4 (Notification delivery for all event types).
- پوشش تست ≥80% برای admin handlers و notification engine.
نکات:
- Admin actions باید audit log داشته باشند.
- Notification delivery failures باید به admin گزارش شوند.
- RabbitMQ connection باید با retry و reconnect مدیریت شود.
برنامه گام‌به‌گام: پیاده‌سازی admin handlers، پیاده‌سازی notification listener، پیاده‌سازی notification sender، integration با RabbitMQ، نوشتن تست‌ها، load testing notification engine.
تست‌ها: M30-E2E-1..4.
Assumptions & Open Questions: آیا admin notification‌ها priority بالاتری دارند؟ آیا admin می‌تواند notification history را ببیند؟

مرحله 31: Telegram Bot - File Upload/Download و Evidence Management
پیش‌نیازها: مراحل 26، 27، 28، 29، 18.
وابستگی‌ها: مراحل 32، 33، 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/Workflow_Statecharts.pdf` (M7), `api/settlement_api.yaml` (M13), `artefacts/telegram_bot/TG_User_Flows.pdf` (M26).
- خروجی: `src/telegram_bot/handlers/file_manager.py`, `src/telegram_bot/services/evidence_validator.py`, `artefacts/telegram_bot/File_Handling_Guide.md`, `artefacts/telegram_bot/Evidence_Verification_Rules.xlsx`.
خروجی‌های ملموس:
- File Upload Handler: دریافت فایل‌ها (تصاویر رسید بانکی، اسکرین‌شات، مدارک) با validation (حجم، فرمت، محتوا).
- File Download Handler: ارائه فایل‌های بارگذاری‌شده به ادمین برای بررسی.
- Evidence Validator: بررسی checksum، تاریخ/زمان، قالب رسید.
- File Storage Integration: ذخیره فایل‌ها در backend و دریافت file_id.
- Documentation: راهنمای کاربری برای بارگذاری مدارک و قوانین پذیرش.
معیار پذیرش:
- کاربر می‌تواند فایل‌های مختلف (JPEG, PNG, PDF) را بارگذاری کند.
- حجم فایل محدود شده (max 10MB) و validation انجام می‌شود.
- فایل‌ها با checksum و metadata ذخیره می‌شوند.
- Admin می‌تواند فایل‌های مربوط به هر RFQ را مشاهده و دانلود کند.
- Evidence validator قوانین M18 را اعمال می‌کند (رسید بانکی با کدرهگیری، TxID معتبر).
- تست‌های E2E: M31-E2E-1 (Upload receipt image)، M31-E2E-2 (Upload invalid file)، M31-E2E-3 (Download evidence as admin)، M31-E2E-4 (Evidence validation rules).
- پوشش تست ≥85% برای file handling و validation.
نکات:
- فایل‌های آپلود شده باید با encryption در backend ذخیره شوند.
- Rate limiting برای file upload لازم است (3 files/min).
- فایل‌های بزرگ باید با progress indicator نمایش داده شوند.
برنامه گام‌به‌گام: پیاده‌سازی file upload handler، پیاده‌سازی file download handler، پیاده‌سازی evidence validator، integration با backend file storage، نوشتن تست‌ها، تهیه documentation.
تست‌ها: M31-E2E-1..4.
Assumptions & Open Questions: آیا فایل‌ها در Telegram Server ذخیره می‌شوند یا فقط file_id ذخیره می‌شود؟ حداکثر مدت زمان نگهداری فایل‌ها چقدر است؟


مرحله 32: Telegram Bot - State Management و Session Persistence
پیش‌نیازها: مراحل 26، 27، 2، 5.
وابستگی‌ها: مراحل 33، 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_Conversation_States.xlsx` (M26), `schema/schema.sql` (M5).
- خروجی: `src/telegram_bot/persistence/state_manager.py`, `schema/telegram_sessions.sql`, `artefacts/telegram_bot/State_Recovery_Guide.md`, `artefacts/telegram_bot/Session_TTL_Rules.xlsx`.
خروجی‌های ملموس:
- PostgreSQL-based Persistence: ذخیره conversation state در `telegram_sessions` table.
- State Manager: load/save state با TTL و cleanup.
- Recovery Mechanism: بازیابی state در صورت restart bot.
- Session Management: مدیریت concurrent sessions، timeout، cleanup.
- Documentation: راهنمای state management و recovery scenarios.
معیار پذیرش:
- تمام conversation states در PostgreSQL ذخیره می‌شوند.
- Bot پس از restart می‌تواند conversations را ادامه دهد.
- Sessions با TTL مدیریت می‌شوند (24h default).
- Expired sessions به‌صورت خودکار cleanup می‌شوند.
- Concurrent sessions برای یک user به‌درستی مدیریت می‌شوند.
- تست‌های E2E: M32-E2E-1 (State persistence after bot restart)، M32-E2E-2 (Session timeout)، M32-E2E-3 (Concurrent sessions)، M32-E2E-4 (State recovery after crash).
- پوشش تست ≥80% برای state management.
نکات:
- State data باید encrypted ذخیره شود (حاوی اطلاعات حساس).
- State cleanup باید با background job انجام شود.
- State size باید محدود شود (max 100KB per session).
برنامه گام‌به‌گام: طراحی schema، پیاده‌سازی state manager، پیاده‌سازی recovery mechanism، پیاده‌سازی cleanup job، نوشتن تست‌ها، تهیه documentation.
تست‌ها: M32-E2E-1..4.
Assumptions & Open Questions: چه مدت conversations باید نگهداری شوند؟ آیا state versioning نیاز است؟


مرحله 33: Telegram Bot - Error Handling و Recovery
پیش‌نیازها: مراحل 26، 27، 28، 29، 30، 31، 32، 15.
وابستگی‌ها: مراحل 34، 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_User_Flows.pdf` (M26), `artefacts/Error_Taxonomy.md` (M15).
- خروجی: `src/telegram_bot/middleware/error_handler.py`, `src/telegram_bot/services/recovery_service.py`, `artefacts/telegram_bot/Error_Handling_Guide.md`, `artefacts/telegram_bot/Recovery_Playbook.md`.
خروجی‌های ملموس:
- Error Handler Middleware: catch و log تمام exceptions با structured logging.
- User-Friendly Error Messages: پیام‌های فارسی و قابل فهم برای کاربران.
- Recovery Service: retry mechanism برای transient errors، fallback actions.
- Dead Letter Queue: ذخیره failed messages برای manual review.
- Error Taxonomy: دسته‌بندی خطاها (Network, Backend API, Telegram API, User Input, State).
- Documentation: راهنمای troubleshooting و recovery procedures.
معیار پذیرش:
- تمام exceptions لاگ می‌شوند با trace_id و context.
- کاربران پیام خطای واضح دریافت می‌کنند (نه stack trace).
- Transient errors (network timeout) به‌صورت خودکار retry می‌شوند (max 3 attempts).
- Failed messages در DLQ ذخیره می‌شوند برای manual recovery.
- Bot در صورت crash به‌صورت خودکار restart می‌شود (با Windows Service recovery).
- تست‌های E2E: M33-E2E-1 (Network error recovery)، M33-E2E-2 (Backend API error)، M33-E2E-3 (Telegram API rate limit)، M33-E2E-4 (Invalid user input)، M33-E2E-5 (Bot crash recovery).
- پوشش تست ≥85% برای error handling.
نکات:
- خطاهای حساس (credential errors) نباید به user نمایش داده شوند.
- Rate limiting errors باید با exponential backoff مدیریت شوند.
- Critical errors باید به admin اطلاع داده شوند (notification).
برنامه گام‌به‌گام: پیاده‌سازی error handler middleware، پیاده‌سازی recovery service، پیاده‌سازی DLQ، تهیه error messages فارسی، نوشتن تست‌ها، تهیه documentation.
تست‌ها: M33-E2E-1..5.
Assumptions & Open Questions: چه خطاهایی باید به admin اطلاع داده شوند؟ DLQ چه مدت نگهداری شود؟


مرحله 34: Telegram Bot - E2E Testing و Quality Assurance
پیش‌نیازها: مراحل 26، 27، 28، 29، 30، 31، 32، 33، 8.
وابستگی‌ها: مرحله 35.
ورودی‌ها / خروجی‌ها:
- ورودی: `artefacts/telegram_bot/TG_User_Flows.pdf` (M26), `tests/test_*.py` (M8 و مراحل قبل).
- خروجی: `tests/telegram_bot/test_e2e_*.py`, `artefacts/test_reports/M34_telegram_bot_tests.md`, `artefacts/telegram_bot/Test_Coverage_Report.html`, `artefacts/telegram_bot/QA_Checklist.xlsx`.
خروجی‌های ملموس:
- E2E Test Suite: پوشش تمام 15 user flow (M26) با pytest.
- Integration Tests: تست تمام handlers با mock backend API.
- Load Tests: تست عملکرد با 100+ concurrent users.
- Security Tests: تست authentication، authorization، input validation.
- Test Coverage Report: گزارش پوشش تست ≥85%.
- QA Checklist: چک‌لیست کامل برای acceptance testing.
- Documentation: راهنمای اجرای تست‌ها و CI/CD integration.
معیار پذیرش:
- تمام 15 user flow با E2E tests پوشش داده شده‌اند.
- پوشش تست کل پروژه Telegram Bot ≥85%.
- تمام تست‌ها با موفقیت اجرا می‌شوند (0 failures).
- Load test نشان می‌دهد bot می‌تواند 100+ concurrent users را handle کند.
- Security tests تأیید می‌کنند هیچ vulnerability شناخته‌شده‌ای وجود ندارد.
- QA Checklist به‌طور کامل تکمیل و تأیید شده است.
- Test reports در `artefacts/test_reports/M34_*.md` ثبت شده‌اند.
نکات:
- تست‌ها باید در CI/CD pipeline اجرا شوند.
- Mock data باید realistic باشد (از production-like scenarios استفاده شود).
- Performance benchmarks باید با production requirements مقایسه شوند.
برنامه گام‌به‌گام: طراحی test scenarios، پیاده‌سازی E2E tests، پیاده‌سازی integration tests، پیاده‌سازی load tests، پیاده‌سازی security tests، اجرای تست‌ها، تهیه reports، تکمیل QA checklist.
تست‌ها: M34-E2E-1 (Customer complete flow)، M34-E2E-2 (Provider complete flow)، M34-E2E-3 (Admin complete flow)، M34-E2E-4 (Dispute flow)، M34-E2E-5 (Partial-fill flow)، M34-E2E-6 (Load test)، M34-E2E-7 (Security test).
Assumptions & Open Questions: آیا regression tests نیاز است؟ آیا performance benchmarks مشخص هستند؟


مرحله 35: Telegram Bot - Production Deployment و Operations
پیش‌نیازها: مراحل 26، 27، 28، 29، 30، 31، 32، 33، 34، 25.
وابستگی‌ها: هیچ (آخرین مرحله Telegram Bot).
ورودی‌ها / خروجی‌ها:
- ورودی: تمام deliverables M26-M34، `artefacts/Production_Runbook.md` (M25).
- خروجی: `deployment/telegram_bot/install.ps1`, `deployment/telegram_bot/service.xml`, `artefacts/telegram_bot/Deployment_Guide.md`, `artefacts/telegram_bot/Operations_Runbook.md`, `artefacts/telegram_bot/Monitoring_Dashboard.md`.
خروجی‌های ملموس:
- Installation Script: اسکریپت PowerShell برای نصب bot به‌عنوان Windows Service.
- Service Configuration: تنظیمات Windows Service (auto-restart، logging، credentials).
- Deployment Guide: راهنمای کامل deployment با checklist.
- Operations Runbook: دستورالعمل‌های operational (start/stop، backup، rollback، troubleshooting).
- Monitoring Dashboard: داشبورد مانیتورینگ bot metrics (uptime، message rate، error rate، latency).
- Health Check Endpoint: endpoint برای monitoring bot health.
- Log Aggregation: تنظیمات centralized logging.
معیار پذیرش:
- Bot به‌عنوان Windows Service نصب و اجرا می‌شود.
- Service در صورت crash به‌صورت خودکار restart می‌شود.
- تمام credentials از Windows Credential Manager خوانده می‌شوند.
- Health check endpoint پاسخ می‌دهد و status bot را نشان می‌دهد.
- Logs به‌صورت structured و centralized ذخیره می‌شوند.
- Monitoring dashboard metrics اصلی را نمایش می‌دهد.
- Deployment guide و operations runbook تکمیل و test شده‌اند.
- Rollback procedure تست شده و کار می‌کند.
نکات:
- Bot باید با least privilege user اجرا شود.
- Secrets باید encrypted نگهداری شوند.
- Log rotation باید پیکربندی شود (max 100MB per file).
- Backup strategy برای conversation state و files تعریف شود.
برنامه گام‌به‌گام: آماده‌سازی installation script، پیکربندی Windows Service، تهیه deployment guide، تهیه operations runbook، پیاده‌سازی health check، پیکربندی monitoring، استقرار آزمایشی، اجرای rollback test، تحویل نهایی.
تست‌ها: M35-E2E-1 (Fresh installation)، M35-E2E-2 (Service auto-restart)، M35-E2E-3 (Health check)، M35-E2E-4 (Rollback procedure).
Assumptions & Open Questions: آیا blue-green deployment نیاز است؟ آیا disaster recovery plan مشخص است؟


